---
title: Stock Market
output: html_document
author: Jeffrey Mei
date: 2025-08-19
server: shiny
---

```{R}
#| echo: false 
#| context: setup
#| message: false
#| warning: false

# Load Packages
devtools::load_all("~/Documents/Research/Code/ECE")
library(tidyverse)
library(changepoint)
library(tidyquant)
```

# Stock Market Data
Here, we compare the closing cost of `MSFT`, `META`, and `NVDA` stocks. 

Under the standard segmentation method -- i.e., PELT with BIC penalty with `minseglen = 2`, we get the following mean-segmentation. It is difficult to see what PELT determines as the best mean-segmentation, because the breaks are so frequent. This can be adjusted by utilizing a manual penalty or changing the `minseglen`.

```{R}
dateRangeInput("daterange", "Choose dates:",
               start = "2020-01-01",
               end   = "2025-05-01",
               min   = "2010-01-01",
               max   = Sys.Date())
```

```{R}
#| context: server

df_reactive <- reactive({
  tq_get(c("MSFT", "META", "NVDA"),
         from = input$daterange[1],
         to   = input$daterange[2]) %>%
    dplyr::select(symbol, date, close) %>%
    pivot_wider(names_from = symbol, values_from = close) %>%
    drop_na() %>%
    rename(index = date, X1 = MSFT, X2 = META, X3 = NVDA) %>%
    mutate(
      X1_mean = segment_mean(X1),
      X2_mean = segment_mean(X2),
      X3_mean = segment_mean(X3)
    )
})

#| context: server
output$stockPlot <- renderPlot({
  df <- df_reactive()
  ggplot(df, aes(x=index)) +
    geom_line(aes(y=X1), color="red") +
    geom_line(aes(y=X2), color="blue") +
    geom_line(aes(y=X3), color="green") +
    geom_line(aes(y=X1_mean), color="red", linetype="dashed") +
    geom_line(aes(y=X2_mean), color="blue", linetype="dashed") +
    geom_line(aes(y=X3_mean), color="green", linetype="dashed") +
    labs(title="Change Point Segmentation", x="", y="") +
    theme_minimal()
})

output$residualPlot <- renderPlot({
  df <- df_reactive()
  ggplot(df, aes(x=index)) +
    geom_hline(yintercept=0) +
    geom_line(aes(y=X1 - X1_mean), color="red") +
    geom_line(aes(y=X2 - X2_mean), color="blue") +
    geom_line(aes(y=X3 - X3_mean), color="green") +
    labs(title="Segmentation Residuals", x="", y="") +
    theme_minimal()
})

output$acfPlots <- renderPlot({
  df <- df_reactive()
  par(mfrow=c(1,3))
  acf(df$X1 - df$X1_mean, main="MSFT")
  acf(df$X2 - df$X2_mean, main="META")
  acf(df$X3 - df$X3_mean, main="NVDA")
  par(mfrow=c(1,1))
})

#| context: server
output$ece_cov <- renderPrint({
  df <- df_reactive()
  demean_cov <- cov(cbind(
    df$X1 - df$X1_mean,
    df$X2 - df$X2_mean,
    df$X3 - df$X3_mean
  ))
  colnames(demean_cov) <- rownames(demean_cov) <- c("MSFT","META","NVDA")

  ece_cov <- matrix(c(
    equiv.cov(df$X1, df$X1),
    equiv.cov(df$X1, df$X2),
    equiv.cov(df$X1, df$X3),
    equiv.cov(df$X2, df$X1),
    equiv.cov(df$X2, df$X2),
    equiv.cov(df$X2, df$X3),
    equiv.cov(df$X3, df$X1),
    equiv.cov(df$X3, df$X2),
    equiv.cov(df$X3, df$X3)
  ), nrow=3, byrow=TRUE)
  colnames(ece_cov) <- rownames(ece_cov) <- c("MSFT","META","NVDA")

  cat("Demean Covariance:\n")
  print(demean_cov)
  cat("\nECE Covariance:\n")
  print(ece_cov)
})

output$ece_cor <- renderPrint({
  df <- df_reactive()
  demean_cor <- cor(cbind(
    df$X1 - df$X1_mean,
    df$X2 - df$X2_mean,
    df$X3 - df$X3_mean
  ))
  colnames(demean_cor) <- rownames(demean_cor) <- c("MSFT","META","NVDA")

  ece_cor <- matrix(c(
    ece.test(df$X1, df$X1)$estimate,
    ece.test(df$X1, df$X2)$estimate,
    ece.test(df$X1, df$X3)$estimate,
    ece.test(df$X2, df$X1)$estimate,
    ece.test(df$X2, df$X2)$estimate,
    ece.test(df$X2, df$X3)$estimate,
    ece.test(df$X3, df$X1)$estimate,
    ece.test(df$X3, df$X2)$estimate,
    ece.test(df$X3, df$X3)$estimate
  ), nrow=3, byrow=TRUE)
  colnames(ece_cor) <- rownames(ece_cor) <- c("MSFT","META","NVDA")

  cat("Demean Correlation:\n")
  print(demean_cor)
  cat("\nECE Correlation:\n")
  print(ece_cor)
})
```

::: {.panel-tabset}

## Plot
```{R}
plotOutput("stockPlot")
```


## Residuals
```{R}
plotOutput("residualPlot")
```

We see a little bit of heteroscedasticity. Whatever variance/covariance we estimate, it will be the average across this time interval.

## ACF
```{R}
plotOutput("acfPlots")
```

Given this segmentation, it looks like there's still some auto-correlation. It's hard to claim this is due to inadequate fitting since it the fit is already so tight. This intrinsic auto-correlation deflates the estimated correlation. This means our estimated correlation will be deflated from the true value. 
:::



::: {.panel-tabset}

## Correlation
```{R}
verbatimTextOutput("ece_cor")
```

## Covariance
```{R}
verbatimTextOutput("ece_cov")
```

:::

# Conclusions
The way `MSFT`, `META`, and `NVDA` were chosen is because we additionally compare `AAPL`, `GOOG`, and `AMZN`, but they yielded nonsensical results -- the correlation coefficient would be greater than 1 if it could be calculated at all. This is a major problem in finding applications for ECE. Many of the time series result in NA values. This is a huge detriment of the technique. 

Moreover, the estimate is extremely unstable. Try varying the end-date for the data-collection. You'll find the estimates vary widely, and often times you'll find NA values. 


# More
How do we determine which of the analyses are more accurate? Simulations should give a hint as to the behavior between the two 

Are we supposed to be using log-returns instead? 

Can you find the penalty value that minimizes the difference between ECE estimate and segmented-mean estimate? 

To evaluate the stability, let's plot correlation of `MSFT-META`, `MSFT-NVDA`, AND `META-NVDA` over time. 


```{R}
#| echo: false
get_weights <- function(L){
    K = sum((1:L)^2)
    S = sum(1:L)
    norm = L * K - S^2
    a = sapply(1:L, function(k) K - k * S)  / norm
    return(a)
}

Ak <- function(n, k){
    (1/n) * (diag(n) - 0.5 * (Ck(n, k) + t(Ck(n, k))))
}

Ck <- function(n, k){
    if(k == 0){
        return(diag(1, n))
    }
    rbind(diag(1, n)[-(1:k),], 
          diag(1, n)[1:k,])
}

b_to_A <- function(b, n, L){
    A = sapply(1:L, function(k) b[k] * Ak(n, k), simplify=F)
    return(Reduce('+', A))
}

est <- function(X, L=2){
    n = nrow(X)
    b = get_weights(L)
    A = b_to_A(b, n, L)
    return(t(X) %*% A %*% X)
}

#est(cbind(X1, X2, X3), L=2)

```


